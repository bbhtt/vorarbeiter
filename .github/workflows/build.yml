name: Build pipeline
run-name: build ${{ inputs.app_id }}/${{ inputs.branch }} from ${{ inputs.git_ref }}

concurrency:
  group: build-${{ inputs.app_id }}-${{ inputs.branch }}-${{ inputs.git_ref }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      app_id:
        description: 'Application ID'
        required: true
        default: org.vim.Vim
      branch:
        description: 'Build branch (stable/beta/test)'
        required: true
        default: stable
      git_ref:
        description: 'Git reference'
        required: true
        default: master
      build_url:
        description: 'Build ID'
        required: true
        default: "0"
      repo_token:
        description: 'Repository token'
        required: true
      callback_url:
        description: 'Callback URL'
        required: true
      callback_token:
        description: 'Callback token'
        required: true

jobs:
  check-event-type:
    runs-on: ubuntu-latest
    steps:
      - name: Check event type
        run: |
          if [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            echo "This workflow only supports workflow_dispatch events"
            exit 1
          fi

  update-log-url:
    runs-on: ubuntu-latest
    needs: check-event-type
    steps:
      - name: Report log URL to the backend
        run: |
          CALLBACK_TOKEN="$(jq -r '.inputs.callback_token' $GITHUB_EVENT_PATH)"
          echo "::add-mask::$CALLBACK_TOKEN"

          curl -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d '{"log_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"}' \
            "${{ inputs.callback_url }}"

  validate-manifest:
    runs-on: ubuntu-latest
    needs: [check-event-type, update-log-url]
    steps:
      - name: Set variables
        run: |
          echo "APP_ID=${{ inputs.app_id }}" >> $GITHUB_ENV
          echo "BRANCH=${{ inputs.branch }}" >> $GITHUB_ENV
          echo "REPO=https://github.com/flathub/${{ inputs.app_id }}" >> $GITHUB_ENV
          echo "REF=${{ inputs.git_ref }}" >> $GITHUB_ENV
          echo "BUILD_URL=https://hub.flathub.org/api/v1/build/${{ inputs.build_url }}" >> $GITHUB_ENV

      - name: Create work directory
        run: |
          mkdir -p ${GITHUB_WORKSPACE}/work
          chmod 777 ${GITHUB_WORKSPACE}/work

      - name: Download justfile
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            curl https://raw.githubusercontent.com/barthalion/justpak/refs/heads/main/justfile -o justfile

      - name: Checkout repository
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            -e REPO \
            -e REF \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            /bin/bash -c '
              git config --global --add safe.directory "*"
              just checkout $REPO $REF
            '

      - name: Detect app ID of the new submission
        if: ${{ github.event.inputs.app_id == 'flathub' }}
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            -e APP_ID \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            just detect-appid /work > app_id

          echo "APP_ID=$(cat app_id)" >> $GITHUB_ENV

      - name: Validate manifest
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            -e APP_ID \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            just validate-manifest $APP_ID

  setup-matrix:
    runs-on: ubuntu-latest
    needs: [check-event-type, update-log-url]
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: flathub/${{ inputs.app_id }}
          fetch-depth: 1
          path: repo

      - id: set-matrix
        shell: python
        run: |
          import json
          import os

          arches = ["x86_64", "aarch64"]

          if os.path.exists("repo/flathub.json"):
              with open("repo/flathub.json") as f:
                  flathub_json = json.load(f)

              if "only-arches" in flathub_json:
                  arches = flathub_json["only-arches"]

              if "skip-arches" in flathub_json:
                  arches = list(set(arches) - set(flathub_json["skip-arches"]))

          matrix = {"include": []}
          for arch in arches:
              arch = arch.strip()
              match arch:
                  case "x86_64":
                      runner = "ubuntu-24.04"
                  case "aarch64":
                      runner = "ubuntu-24.04-arm"
                  case _:
                      print(f"Error: Unsupported architecture: {arch}")
                      exit(1)

              matrix["include"].append({"arch": arch, "runner": runner})

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"matrix={json.dumps(matrix)}\\n")

  build:
    name: build-${{ matrix.arch }}
    runs-on: ${{ matrix.runner }}
    needs: [validate-manifest, setup-matrix]
    strategy:
      fail-fast: true
      matrix:
        include: ${{ fromJSON(needs.setup-matrix.outputs.matrix).include }}
    steps:
      - name: Set variables
        run: |
          echo "APP_ID=${{ inputs.app_id }}" >> $GITHUB_ENV
          echo "BRANCH=${{ inputs.branch }}" >> $GITHUB_ENV
          echo "REPO=https://github.com/flathub/${{ inputs.app_id }}" >> $GITHUB_ENV
          echo "REF=${{ inputs.git_ref }}" >> $GITHUB_ENV
          echo "BUILD_URL=https://hub.flathub.org/api/v1/build/${{ inputs.build_url }}" >> $GITHUB_ENV

          REPO_TOKEN="$(jq -r '.inputs.repo_token' $GITHUB_EVENT_PATH)"
          echo "::add-mask::$REPO_TOKEN"
          echo "REPO_TOKEN=$REPO_TOKEN" >> $GITHUB_ENV

      - name: Create work directory
        run: |
          mkdir -p ${GITHUB_WORKSPACE}/work
          chmod 777 ${GITHUB_WORKSPACE}/work

      - name: Free up disk space
        run: |
          sudo rm -rf /opt/* /usr/local/.ghcup || true
          sudo rm -rf /swapfile || true
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /usr/share/dotnet /usr/share/swift
          sudo rm -rf /usr/local/share/boost /usr/local/share/powershell
          sudo rm -rf /usr/lib/google-cloud-sdk /usr/lib/jvm
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Download justfile
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            curl https://raw.githubusercontent.com/barthalion/justpak/refs/heads/main/justfile -o justfile

      - name: Checkout repository
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            -e REPO \
            -e REF \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            /bin/bash -c '
              git config --global --add safe.directory "*"
              just checkout $REPO $REF
            '

      - name: Detect app ID of the new submission
        if: ${{ github.event.inputs.app_id == 'flathub' }}
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            -e APP_ID \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            just detect-appid /work > app_id

          echo "APP_ID=$(cat app_id)" >> $GITHUB_ENV

      - name: Build flatpak
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            -e APP_ID \
            -e BRANCH \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            /bin/bash -c '
              git config --global --add safe.directory "*"
              just prepare-env
              just build $APP_ID $BRANCH
            '

      - name: Commit screenshots
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            just commit-screenshots

      - name: Validate build
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            just validate-build

      - name: Generate deltas
        run: |
          docker run --rm --privileged \
            --entrypoint="" \
            -v "${GITHUB_WORKSPACE}/work:/work" \
            -w /work \
            ghcr.io/flathub-infra/flatpak-builder-lint:latest \
            just generate-deltas

  callback:
    runs-on: ubuntu-latest
    needs: [check-event-type, update-log-url, validate-manifest, setup-matrix, build]
    if: ${{ always() }}
    steps:
      - name: Report job status
        run: |
          CALLBACK_TOKEN="$(jq -r '.inputs.callback_token' $GITHUB_EVENT_PATH)"
          echo "::add-mask::$CALLBACK_TOKEN"

          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            status="failure"
          elif [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            status="cancelled"
          else
            status="success"
          fi

          curl -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $CALLBACK_TOKEN" \
            -d "{\"status\": \"${status}\"}" \
            "${{ inputs.callback_url }}"
